#Geography 920 - Week 12
#Daniel Segessenman

###Question 1 (Coin Flips) Function code from Coin_flips.R
bin.prob <- function(p,n,h){
  probab  <- factorial(n)*p^h*(1-p)^(n-h)/(factorial(h)*factorial(n-h))
}

normalizing.fun <- function(n,h,prior.n,prior.h){
  beta <- prior.n - prior.h+1
  prior.h <- prior.h+1
  nc <- factorial(n)*beta(h+prior.h,n-h+beta)/(factorial(h)*factorial(n-h)*beta(prior.h,beta))
}

posterior.fun <- function(probs,n,h,prior.n,prior.h){

  #define additional variables
  beta <- prior.n - prior.h+1
  alpha <- prior.h+1

  #Likelihiood
  L <- dbinom(h,n,probs)

  #Prior
  prior <- dbeta(probs,alpha,beta)
  prior <- prior/sum(prior)
  #normalizing constant
  nc <- factorial(n)*beta(h+alpha,n-h+beta)/(factorial(h)*factorial(n-h)*beta(alpha,beta))

  posterior <- L*prior/nc

  output <- data.frame(parameter=probs,Posterior=posterior,Prior=prior,Likelihood = L)
  matplot(output$parameter,output[,2:4],type='l',xlab='',ylab='')
  mtext(side=1,line=2.2,font=2,expression(Theta),cex=1)
  mtext(side=2,line=2.2,font=2,cex=1,'Probability')
  legend('topleft',col=1:3,lty=1:3,legend=c('Posterior','Prior','Likelihood'))
  return(output)
}

# Observations for Likelihood
n <- 20
h <- 15

# Coin flips for prior
prior.n <- 20
prior.h <-  10

probs <-  seq(0,1,0.01)

outp <- posterior.fun(probs=probs,
                      n = n,
                      h = h,
                      prior.n = prior.n,
                      prior.h = prior.h)

#Equal number of coin flips for prior and likelihood
p1a <- posterior.fun(probs, n=20, h=15, prior.n=20, prior.h=15)
p1b <- posterior.fun(probs, n=100, h=75, prior.n=100, prior.h=75)
#Yes, the absolute numbers do matter... they can change the probability if not
#the location of the modes on the x-axis (theta)

#Change number of coin flips used as prior - no coin flips
p2a <- posterior.fun(probs, n=0, h=0, prior.n, prior.h)

#Change number of coin flips used as prior - half the flips
p2b <- posterior.fun(probs, n=n, h=h, prior.n=10, prior.h=5)

#Change number of coin flips used as prior - double the flips
p2c <- posterior.fun(probs, n=n, h=h, prior.n=40, prior.h=20)

#Change number of coin flips used as data - only 4
p3a <- posterior.fun(probs, n=4, h=3, prior.n=prior.n, prior.h=prior.h)

#Change number of coin flips used as data - twice the prior
p3b <- posterior.fun(probs, n=2*prior.n, h=2*prior.h, prior.n=prior.n, prior.h=prior.h)

#Change number of coin flips used as data - five times the prior
p3b <- posterior.fun(probs, n=5*prior.n, h=5*prior.h, prior.n=prior.n, prior.h=prior.h)

#Two parts: 40 coin flips and doing 20 flips then use new posterior as prior and add 20 flips
p4a <- posterior.fun(probs, n=n, h=h, prior.n=prior.n, prior.h=prior.h)

#Use Posterior probability as prior and compare to 40 flips as normal
p4b <- posterior.fun(probs, n=40, h=30, prior.n=40*.65, prior.h=30*.65)
p4c <- posterior.fun(probs, n=40, h=30, prior.n=prior.n, prior.h=prior.h)
#Interesting, the postserior probability with 40 flips causes the prior, posterior,
#and likelihood probabilities to align!


###Question 2 - Markov chain Monte Carlo sampling

#State populations downloaded from worldpopulationreview.com
statepop <- read.csv(file="C:/Users/Daniel/Documents/Geography 920/Week 12/statepop.csv", header = TRUE, sep = ",")

#Create a blank column in statepop to collect number of visits and a proportion of population column
statepop$visits <- 0
propsum <- sum(statepop$X2018.Population)
statepop$prop.pop <- statepop$X2018.Population/propsum

#Number of repetitions
#n = (1:100)
n = (1:1000)
#These two took my tablet a few minutes
#n = (1:10000)
#n = (1:100000)
#Takes a good bit of time, good for breaks
#n = (1:1000000)

#Code to compare two states populations and determine if a 'visit' occurs
s1 <- statepop[sample(nrow(statepop), 1), ]
s2 <- statepop[sample(nrow(statepop), 1), ]
for (i in n) {
  repeat {
    state_id <- s2$Rank
    if(s1$prop.pop/s2$prop.pop > 1) {
      s1 <- statepop[sample(nrow(statepop), 1), ]
      s2 <- statepop[sample(nrow(statepop), 1), ]
      } else {
      moveprob <- s1$prop.pop/s2$prop.pop
      test <- rbinom(1, 1, moveprob)
      if(test < 1) {
        statepop$visits[state_id] <- statepop$visits[state_id] + 1
        s1 <- statepop[sample(nrow(statepop), 1), ]
        s2 <- statepop[sample(nrow(statepop), 1), ]
        break
        } else {
        s1 <- statepop[sample(nrow(statepop), 1), ]
        s2 <- statepop[sample(nrow(statepop), 1), ]
      }
    }
  }
}

#Plot 'visits' to each state
visitsum <- sum(statepop$visits)
statepop$prop_visits <- statepop$visits/visitsum
barplot(statepop$prop_visits, names.arg=statepop$State, las=2)
barplot(statepop$prop.pop,  names.arg=statepop$State, las=2)
