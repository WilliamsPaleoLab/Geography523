WEEK 12: Bayesian Inference
Brittany Hupp


Question 1: Coin flips
bin.prob <- function(p,n,h){
  probab  <- factorial(n)*p^h*(1-p)^(n-h)/(factorial(h)*factorial(n-h))
}

normalizing.fun <- function(n,h,prior.n,prior.h){
  beta <- prior.n - prior.h+1
  prior.h <- prior.h+1
  nc <- factorial(n)*beta(h+prior.h,n-h+beta)/(factorial(h)*factorial(n-h)*beta(prior.h,beta))
}



posterior.fun <- function(probs,n,h,prior.n,prior.h){

  #define additional variables
  beta <- prior.n - prior.h+1
  alpha <- prior.h+1

  #Likelihiood
  L <- dbinom(h,n,probs)

  #Prior
  prior <- dbeta(probs,alpha,beta)
  prior <- prior/sum(prior)
  #normalizing constant
  nc <- factorial(n)*beta(h+alpha,n-h+beta)/(factorial(h)*factorial(n-h)*beta(alpha,beta))

  posterior <- L*prior/nc

  output <- data.frame(parameter=probs,Posterior=posterior,Prior=prior,Likelihood = L)
  matplot(output$parameter,output[,2:4],type='l',xlab='',ylab='')
  mtext(side=1,line=2.2,font=2,expression(Theta),cex=1)
  mtext(side=2,line=2.2,font=2,cex=1,'Probability')
  legend('topleft',col=1:3,lty=1:3,legend=c('Posterior','Prior','Likelihood'))
  return(output)
}

# Observations for LIkelihood
n <- 20
h <- 15

# Coin flips for prior
prior.n <- 20
prior.h <-  10

probs <-  seq(0,1,0.01)

outp <- posterior.fun(probs=probs,
                      n = n,
                      h = h,
                      prior.n = prior.n,
                      prior.h = prior.h)

#Equal number of coin flips for prior and likelihood
outp <- posterior.fun(probs=probs, n = 30, h = 15, prior.n = 30, prior.h = 10)
outp <- posterior.fun(probs=probs, n = 50, h = 15, prior.n = 50, prior.h = 10)
#By changing the absolute number of coin flips, you are changing the probability
#of the prior and likelihood which will ultimately change the output of the posterior.

#Change number of coin flips used as prior
# no coin flips
outp <- posterior.fun(probs=probs, n = 20, h = 15, prior.n = 0, prior.h = 10)
# half the the data
outp <- posterior.fun(probs=probs, n = 20, h = 15, prior.n = 20/2, prior.h = 10/2)
# twice the data
outp <- posterior.fun(probs=probs, n = 20, h = 15, prior.n = 20*2, prior.h = 10*2)

# Change number of coin flips used as data (always keep the proportion of heads at 0.75*n)
# only four coin flips
outp <- posterior.fun(probs=probs, n = 4, h = 1, prior.n = 20, prior.h = 10)
# twice the number of prior flips
outp <- posterior.fun(probs=probs, n = 40, h = 30, prior.n = 20, prior.h = 10)
# five times the number of prior flips
outp <- posterior.fun(probs=probs, n = 100, h = 75, prior.n = 20, prior.h = 10)

# divide your coin flips into two parts:
# 20 flips then use the new posterior as prior and add an additional 20 coin flips
outp <- posterior.fun(probs=probs, n = 20, h = 15, prior.n = 20, prior.h = 10)
outp <- posterior.fun(probs=probs, n = 40, h = 35, prior.n = 40*0.62, prior.h = 20*0.62)
# compare this to 40 coin flips
outp2 <- posterior.fun(probs=probs, n = 40, h = 30, prior.n = 40, prior.h = 20)


QUESTION 2: Markov chain Monte Carlo sampling
#State populations downloaded from worldpopulationreview.com
statepop <- read.csv(file="C:/Users/britt/OneDrive/Documents/Paleoeco GitHub/Lab 12- Bayesian Inference/state population data.csv", header = TRUE, sep = ",")

#Create a blank column in statepop to collect number of visits and a proportion of population column
statepop$visits <- 0
propsum <- sum(statepop$X2018.Population)
statepop$prop.pop <- statepop$X2018.Population/propsum

#Number of repetitions
n = (1:1000)
#Repeated for n= 10,000; n= 100,000; n=1,000,000

#Code comparing two state populations and if a visit would occur
st1 <- statepop[sample(nrow(statepop), 1), ]
st2 <- statepop[sample(nrow(statepop), 1), ]
for (i in n) {
  repeat {
    state_id <- st2$Rank
    if(st1$prop.pop/st2$prop.pop > 1) {
      st1 <- statepop[sample(nrow(statepop), 1), ]
      st2 <- statepop[sample(nrow(statepop), 1), ]
      } else {
      moveprob <- st1$prop.pop/st2$prop.pop
      test <- rbinom(1, 1, moveprob)
      if(test < 1) {
        statepop$visits[state_id] <- statepop$visits[state_id] + 1
        st1 <- statepop[sample(nrow(statepop), 1), ]
        st2 <- statepop[sample(nrow(statepop), 1), ]
        break
        } else {
        st1 <- statepop[sample(nrow(statepop), 1), ]
        st2 <- statepop[sample(nrow(statepop), 1), ]
      }
    }
  }
}

#Plot number of visits for each state
visitsum <- sum(statepop$visits)
statepop$prop_visits <- statepop$visits/visitsum

#Plot of visits per state
barplot(statepop$prop_visits, names.arg=statepop$State, las=2)
#Plot of actual population per state, for comparison
barplot(statepop$prop.pop,  names.arg=statepop$State, las=2)
