---
title: "G920_Lab12_Fastovich"
author: "David Fastovich"
date: "December 7, 2018"
output: 
  html_document:
    theme: spacelab
    highlight: pygments
---

```{r, include=FALSE}
bin.prob <- function(p,n,h){
  probab  <- factorial(n)*p^h*(1-p)^(n-h)/(factorial(h)*factorial(n-h))
}

normalizing.fun <- function(n,h,prior.n,prior.h){
  beta <- prior.n - prior.h+1
  prior.h <- prior.h+1
  nc <- factorial(n)*beta(h+prior.h,n-h+beta)/(factorial(h)*factorial(n-h)*beta(prior.h,beta))
}



posterior.fun <- function(probs,n,h,prior.n,prior.h){
  
  #define additional variables
  beta <- prior.n - prior.h+1
  alpha <- prior.h+1
  
  #Likelihiood
  L <- dbinom(h,n,probs)
  
  #Prior
  prior <- dbeta(probs,alpha,beta)
  prior <- prior/sum(prior)
  #normalizing constant
  nc <- factorial(n)*beta(h+alpha,n-h+beta)/(factorial(h)*factorial(n-h)*beta(alpha,beta))
  
  posterior <- L*prior/nc
  
  output <- data.frame(parameter=probs,Posterior=posterior,Prior=prior,Likelihood = L)
  matplot(output$parameter,output[,2:4],type='l',xlab='',ylab='')
  mtext(side=1,line=2.2,font=2,expression(Theta),cex=1)
  mtext(side=2,line=2.2,font=2,cex=1,'Probability')
  legend('topleft',col=1:3,lty=1:3,legend=c('Posterior','Prior','Likelihood'))
  return(output)
}

# Observations for LIkelihood
n <- 20
h <- 15

# Coin flips for prior
prior.n <- 20
prior.h <-  10 

probs <-  seq(0,1,0.01)

outp <- posterior.fun(probs=probs,
                      n = n,
                      h = h,
                      prior.n = prior.n,
                      prior.h = prior.h)
```

### Question 1
#### Equal number of coin flips for prior and likelihood:
#### Compare modes (maximum value) of prior, likelihood and posterior
```{r}
m.post <- max(outp$Posterior)
m.prior <- max(outp$Prior)
m.like <- max(outp$Likelihood)

plot(outp$Posterior, type = "l", ylim = c(0, 1))
lines(outp$Prior, col = "blue")
lines(outp$Likelihood, col = "red")
legend("topleft", legend = c("Posterior", "Prior", "Likelihood"), col = c("black", "blue", "red"), lty = c(1, 1, 1))
```

Mode       | Variable
----------- | --------
`r m.post`  | Posterior
`r m.prior` | Prior
`r m.like`  | Likelihood

* The likelood mode is the highest and the prior is the lowest. The posterior mode is simply the product of the likelihood mode and the prior mode.

#### Does the absolute number of coin flips matter?
```{r}
flips <- seq(0, 100, 10)

prior <- matrix(ncol = 12, nrow = nrow(outp), data = NA)
likelihood <- matrix(ncol = 12, nrow = nrow(outp), data = NA)
posterior <- matrix(ncol = 12, nrow = nrow(outp), data = NA)

for(i in 1:length(flips)) {
  n <- flips[i]
  outp <- posterior.fun(probs=probs,
                      n = n,
                      h = h,
                      prior.n = prior.n,
                      prior.h = prior.h)
  prior[,i] <- outp$Prior
  likelihood[,i] <- outp$Likelihood
  posterior[,i] <- outp$Posterior
}

plot(outp$parameter, likelihood[,2], type = "l", main = "likelihood", ylim = c(0, 0.5))
lines(outp$parameter, likelihood[,3], col = "red")
lines(outp$parameter, likelihood[,4], col = "blue")
lines(outp$parameter, likelihood[,5], col = "green")
lines(outp$parameter, likelihood[,6], col = "yellow")
lines(outp$parameter, likelihood[,7], col = "orange")

plot(outp$parameter, posterior[,8], type = "l", main = "Posterior", col = "orange")
lines(outp$parameter, posterior[,4], col = "red")
lines(outp$parameter, posterior[,5], col = "blue")
lines(outp$parameter, posterior[,6], col = "green")
lines(outp$parameter, posterior[,7], col = "yellow")
lines(outp$parameter, posterior[,3], col = "black")
```

* The absolute number of coin flips does matter. The more coin flips there are the more narrow the distributions for the likelihhod and posterior become more narrow and therefore generate better esimates of the coins probability.

#### Change number of coin flips used as prior
```{r}
par(mfrow = c(1, 3))
outp.no <- posterior.fun(probs=probs,
                      n = n,
                      h = h,
                      prior.n = 0,
                      prior.h = prior.h)
outp.half <- posterior.fun(probs=probs,
                      n = n,
                      h = h,
                      prior.n = n/2,
                      prior.h = prior.h)
outp.twice <- posterior.fun(probs=probs,
                      n = n,
                      h = h,
                      prior.n = n*2,
                      prior.h = prior.h)
```

#### Change number of coin flips used as data
```{r}
par(mfrow = c(1, 3))
outp.four <- posterior.fun(probs=probs,
                      n = 4,
                      h = (4 * .75),
                      prior.n = prior.n,
                      prior.h = prior.h)
outp.twice <- posterior.fun(probs=probs,
                      n = prior.n * 2,
                      h = ((prior.n * 2) *.75),
                      prior.n = prior.n,
                      prior.h = prior.h)
outp.five <- posterior.fun(probs=probs,
                      n = prior.n * 5,
                      h = ((prior.n * 5) * .75),
                      prior.n = prior.n,
                      prior.h = prior.h)
```

#### Divide your coin flips into two parts: 20 flips and then use the new posterior as a prior, compare this to 40 coin flips
```{r}
outp.first.20 <- posterior.fun(probs=probs,
                      n = 20,
                      h = 15,
                      prior.n = 20,
                      prior.h = 10)

outp.second.20 <- posterior.fun(probs = probs,
                                n = 20, 
                                h = 15,
                                prior.n = 40,
                                prior.h = (40 * probs[max(outp.first.20$Posterior) == outp.first.20$Posterior])) 

outp.40 <- posterior.fun(probs = probs,
                                n = 40, 
                                h = 30,
                                prior.n = 40,
                                prior.h = 20)
plot(outp.second.20$parameter, outp.second.20$Posterior, type = "l")
lines(outp.40$parameter, outp.40$Posterior, col = "red")
```

* The posteriors are for 20 + 20 flips and 40 flips are nearly identical

### Question 2
#### Write a sample testing the assertion that the portion of visits to a state will converge on the proportion of the population
```{r}
pop <- read.csv("populations.csv", stringsAsFactors = FALSE) # Pull in population data

orig.state <- sample(1:50, 1) # Initial random sample
visits <- rep(0, 50) # Vector to hold the number of visits to each state

n = 1000000 # Number of iterations
i = 1 # Counter to break the repeat loop

repeat{
  i = i+1
  new.state <- sample(1:50, 1)
  ratio <- pop[new.state,2]/pop[orig.state,2]
  if(ratio > 1) {
    orig.state <- new.state
    visits[orig.state] = visits[orig.state] + 1
    } else {
    random <- runif(1, 0, 1)
    if(ratio > random)
    orig.state <- new.state
    visits[orig.state] = visits[orig.state] + 1
    }
  if(i == n) {
    break()
  }
}

pop$population[1]/pop$population[2]
visits[1]/visits[2]

```